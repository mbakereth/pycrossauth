var crossauth_frontend=function(y){"use strict";var ur=Object.defineProperty;var Ie=y=>{throw TypeError(y)};var fr=(y,v,S)=>v in y?ur(y,v,{enumerable:!0,configurable:!0,writable:!0,value:S}):y[v]=S;var f=(y,v,S)=>fr(y,typeof v!="symbol"?v+"":v,S),Ue=(y,v,S)=>v.has(y)||Ie("Cannot "+S);var m=(y,v,S)=>(Ue(y,v,"read from private field"),S?S.call(y):v.get(y)),F=(y,v,S)=>v.has(y)?Ie("Cannot add the same private member more than once"):v instanceof WeakSet?v.add(y):v.set(y,S),P=(y,v,S,Z)=>(Ue(y,v,"write to private field"),Z?Z.call(y,S):v.set(y,S),S);var D,j,N,z,W,q,V;var v=Object.defineProperty,S=r=>{throw TypeError(r)},Z=(r,e,t)=>e in r?v(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,l=(r,e,t)=>Z(r,typeof e!="symbol"?e+"":e,t),ue=(r,e,t)=>e.has(r)||S("Cannot "+t),p=(r,e,t)=>(ue(r,e,"read from private field"),t?t.call(r):e.get(r)),G=(r,e,t)=>e.has(r)?S("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),I=(r,e,t,o)=>(ue(r,e,"write to private field"),e.set(r,t),t);class K{}l(K,"active","active"),l(K,"disabled","disabled"),l(K,"awaitingTwoFactorSetup","awaitingtwofactorsetup"),l(K,"awaitingEmailVerification","awaitingemailverification"),l(K,"passwordChangeNeeded","passwordchangeneeded"),l(K,"passwordResetNeeded","passwordresetneeded"),l(K,"factor2ResetNeeded","factor2resetneeded"),l(K,"passwordAndFactor2ResetNeeded","passwordandfactor2resetneeded");class U{}l(U,"session","s:"),l(U,"passwordResetToken","p:"),l(U,"emailVerificationToken","e:"),l(U,"apiKey","api:"),l(U,"authorizationCode","authz:"),l(U,"accessToken","access:"),l(U,"refreshToken","refresh:"),l(U,"mfaToken","omfa:"),l(U,"deviceCode","dc:"),l(U,"userCode","uc:");var k=(r=>(r[r.UserNotExist=0]="UserNotExist",r[r.PasswordInvalid=1]="PasswordInvalid",r[r.EmailNotExist=2]="EmailNotExist",r[r.UsernameOrPasswordInvalid=3]="UsernameOrPasswordInvalid",r[r.InvalidClientId=4]="InvalidClientId",r[r.ClientExists=5]="ClientExists",r[r.InvalidClientSecret=6]="InvalidClientSecret",r[r.InvalidClientIdOrSecret=7]="InvalidClientIdOrSecret",r[r.InvalidRedirectUri=8]="InvalidRedirectUri",r[r.InvalidOAuthFlow=9]="InvalidOAuthFlow",r[r.UserNotActive=10]="UserNotActive",r[r.EmailNotVerified=11]="EmailNotVerified",r[r.TwoFactorIncomplete=12]="TwoFactorIncomplete",r[r.Unauthorized=13]="Unauthorized",r[r.UnauthorizedClient=14]="UnauthorizedClient",r[r.InvalidScope=15]="InvalidScope",r[r.InsufficientScope=16]="InsufficientScope",r[r.InsufficientPriviledges=17]="InsufficientPriviledges",r[r.Forbidden=18]="Forbidden",r[r.InvalidKey=19]="InvalidKey",r[r.InvalidCsrf=20]="InvalidCsrf",r[r.InvalidSession=21]="InvalidSession",r[r.Expired=22]="Expired",r[r.Connection=23]="Connection",r[r.InvalidHash=24]="InvalidHash",r[r.UnsupportedAlgorithm=25]="UnsupportedAlgorithm",r[r.KeyExists=26]="KeyExists",r[r.PasswordChangeNeeded=27]="PasswordChangeNeeded",r[r.PasswordResetNeeded=28]="PasswordResetNeeded",r[r.Factor2ResetNeeded=29]="Factor2ResetNeeded",r[r.Configuration=30]="Configuration",r[r.InvalidEmail=31]="InvalidEmail",r[r.InvalidPhoneNumber=32]="InvalidPhoneNumber",r[r.InvalidUsername=33]="InvalidUsername",r[r.PasswordMatch=34]="PasswordMatch",r[r.InvalidToken=35]="InvalidToken",r[r.MfaRequired=36]="MfaRequired",r[r.PasswordFormat=37]="PasswordFormat",r[r.DataFormat=38]="DataFormat",r[r.FetchError=39]="FetchError",r[r.UserExists=40]="UserExists",r[r.FormEntry=41]="FormEntry",r[r.BadRequest=42]="BadRequest",r[r.AuthorizationPending=43]="AuthorizationPending",r[r.SlowDown=44]="SlowDown",r[r.ExpiredToken=45]="ExpiredToken",r[r.ConstraintViolation=46]="ConstraintViolation",r[r.NotImplemented=47]="NotImplemented",r[r.UnknownError=48]="UnknownError",r))(k||{});class g extends Error{constructor(e,t=void 0){let o,i=500;e==0?(o="User does not exist",i=401):e==1?(o="Password doesn't match",i=401):e==3?(o="Username or password incorrect",i=401):e==4?(o="Client id is invalid",i=401):e==5?(o="Client ID or name already exists",i=500):e==6?(o="Client secret is invalid",i=401):e==7?(o="Client id or secret is invalid",i=401):e==8?(o="Redirect Uri is not registered",i=401):e==9?(o="Invalid OAuth flow type",i=500):e==2?(o="No user exists with that email address",i=401):e==10?(o="Account is not active",i=403):e==33?(o="Username is not in an allowed format",i=400):e==31?(o="Email is not in an allowed format",i=400):e==32?(o="Phone number is not in an allowed format",i=400):e==11?(o="Email address has not been verified",i=403):e==12?(o="Two-factor setup is not complete",i=403):e==13?(o="Not authorized",i=401):e==14?(o="Client not authorized",i=401):e==15?(o="Invalid scope",i=403):e==16?(o="Insufficient scope",i=403):e==23?o="Connection failure":e==22?(o="Token has expired",i=401):e==24?o="Hash is not in a valid format":e==19?(o="Key is invalid",i=401):e==18?(o="You do not have permission to access this resource",i=403):e==17?(o="You do not have the right privileges to access this resource",i=401):e==20?(o="CSRF token is invalid",i=401):e==21?(o="Session cookie is invalid",i=401):e==25?o="Algorithm not supported":e==26?o="Attempt to create a key that already exists":e==27?(o="User must change password",i=403):e==28?(o="User must reset password",i=403):e==29?(o="User must reset 2FA",i=403):e==30?o="There was an error in the configuration":e==34?(o="Passwords do not match",i=401):e==35?(o="Token is not valid",i=401):e==36?(o="MFA is required",i=401):e==37?(o="Password format was incorrect",i=401):e==40?(o="User already exists",i=400):e==42?(o="The request is invalid",i=400):e==38?(o="Session data has unexpected format",i=500):e==39?(o="Couldn't execute a fetch",i=500):e==43?(o="Waiting for authorization",i=200):e==44?(o="Slow polling down by 5 seconds",i=200):e==45?(o="Token has expired",i=401):e==46?(o="Database update/insert caused a constraint violation",i=500):e==47?(o="This method has not been implemented",i=500):(o="Unknown error",i=500),t!=null&&!Array.isArray(t)?o=t:Array.isArray(t)&&(o=t.join(". ")),super(o),l(this,"isCrossauthError",!0),l(this,"httpStatus"),l(this,"code"),l(this,"codeName"),l(this,"messages"),this.code=e,this.codeName=k[e],this.httpStatus=i,this.name="CrossauthError",Array.isArray(t)?this.messages=t:this.messages=[o],Object.setPrototypeOf(this,g.prototype)}static fromOAuthError(e,t){let o;switch(e){case"invalid_request":o=42;break;case"unauthorized_client":o=14;break;case"access_denied":o=13;break;case"unsupported_response_type":o=42;break;case"invalid_scope":o=15;break;case"server_error":o=48;break;case"temporarily_unavailable":o=23;break;case"invalid_token":o=35;break;case"expired_token":o=45;break;case"insufficient_scope":o=35;break;case"mfa_required":o=36;break;case"authorization_pending":o=43;break;case"slow_down":o=44;break;default:o=48}return new g(o,t)}get oauthErrorCode(){switch(this.code){case 42:return"invalid_request";case 14:return"unauthorized_client";case 13:return"access_denied";case 15:return"invalid_scope";case 23:return"temporarily_unavailable";case 35:return"invalid_token";case 36:return"mfa_required";case 43:return"authorization_pending";case 44:return"slow_down";case 45:return"expired_token";case 22:return"expired_token";default:return"server_error"}}static asCrossauthError(e,t){if(e instanceof Error)return"isCrossauthError"in e?e:new g(48,e.message);if("errorCode"in e){let i=48;try{i=Number(e.errorCode)??48}catch{}let n=t??k[i];return"errorMessage"in e?n=e.errorMessage:"message"in e&&(n=e.message),new g(i,n)}let o=t??k[48];return"message"in e&&(o=e.message),new g(48,o)}}const J=class R{constructor(e){if(l(this,"level"),e)this.level=e;else if(typeof process<"u"&&"CROSSAUTH_LOG_LEVEL"in process.env){const t=(process.env.CROSSAUTH_LOG_LEVEL??"ERROR").toUpperCase();R.levelName.includes(t)?this.level=R.levelName.indexOf(t):this.level=R.Error}else this.level=R.Error}static get logger(){return globalThis.crossauthLogger}setLevel(e){this.level=e}log(e,t){e<=this.level&&(typeof t=="string"?console.log("Crossauth "+R.levelName[e]+" "+new Date().toISOString(),t):console.log(JSON.stringify({level:R.levelName[e],time:new Date().toISOString(),...t})))}error(e){this.log(R.Error,e)}warn(e){this.log(R.Warn,e)}info(e){this.log(R.Info,e)}debug(e){this.log(R.Debug,e)}static setLogger(e,t){globalThis.crossauthLogger=e,globalThis.crossauthLoggerAcceptsJson=t}};l(J,"None",0),l(J,"Error",1),l(J,"Warn",2),l(J,"Info",3),l(J,"Debug",4),l(J,"levelName",["NONE","ERROR","WARN","INFO","DEBUG"]);let c=J;function h(r){let e;typeof r=="object"&&"err"in r&&typeof r.err=="object"&&(e=r.err.stack);try{typeof r=="object"&&"err"in r&&typeof r.err=="object"&&r.err&&"message"in r.err&&!("msg"in r)&&(r.msg=r.err.message)}catch{}try{typeof r=="object"&&"err"in r&&typeof r.err=="object"&&(r.err={...r.err,stack:e})}catch{}try{typeof r=="object"&&"err"in r&&!("msg"in r)&&(r.msg=r.msg="An unknown error occurred")}catch{}try{typeof r=="object"&&"cerr"in r&&"isCrossauthError"in r.cerr&&r.cerr&&(r.errorCode=r.cerr.code,r.errorCodeName=r.cerr.codeName,r.httpStatus=r.cerr.httpStatus,"msg"in r||(r.msg=r.cerr.message),delete r.cerr)}catch{}return typeof r=="string"||globalThis.crossauthLoggerAcceptsJson?r:JSON.stringify(r)}globalThis.crossauthLogger=new c(c.None),globalThis.crossauthLoggerAcceptsJson=!0;const fe={issuer:"",authorization_endpoint:"",token_endpoint:"",jwks_uri:"",response_types_supported:[],subject_types_supported:[],response_modes_supported:["query","fragment"],grant_types_supported:["authorization_code","implicit"],id_token_signing_alg_values_supported:[],claim_types_supported:["normal"],claims_parameter_supported:!1,request_parameter_supported:!1,request_uri_parameter_supported:!0,require_request_uri_registration:!1},ee=crypto,ge=r=>r instanceof CryptoKey,re=new TextEncoder,Y=new TextDecoder;function Oe(...r){const e=r.reduce((i,{length:n})=>i+n,0),t=new Uint8Array(e);let o=0;for(const i of r)t.set(i,o),o+=i.length;return t}const Ne=r=>{const e=atob(r),t=new Uint8Array(e.length);for(let o=0;o<e.length;o++)t[o]=e.charCodeAt(o);return t},$=r=>{let e=r;e instanceof Uint8Array&&(e=Y.decode(e)),e=e.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return Ne(e)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class te extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(e){var t;super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,(t=Error.captureStackTrace)==null||t.call(Error,this,this.constructor)}}class O extends te{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class b extends te{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class M extends te{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class He extends te{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}function H(r,e="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${e} must be ${r}`)}function oe(r,e){return r.name===e}function ce(r){return parseInt(r.name.slice(4),10)}function je(r){switch(r){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function Ke(r,e){if(e.length&&!e.some(t=>r.usages.includes(t))){let t="CryptoKey does not support this operation, its usages must include ";if(e.length>2){const o=e.pop();t+=`one of ${e.join(", ")}, or ${o}.`}else e.length===2?t+=`one of ${e[0]} or ${e[1]}.`:t+=`${e[0]}.`;throw new TypeError(t)}}function xe(r,e,...t){switch(e){case"HS256":case"HS384":case"HS512":{if(!oe(r.algorithm,"HMAC"))throw H("HMAC");const o=parseInt(e.slice(2),10);if(ce(r.algorithm.hash)!==o)throw H(`SHA-${o}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!oe(r.algorithm,"RSASSA-PKCS1-v1_5"))throw H("RSASSA-PKCS1-v1_5");const o=parseInt(e.slice(2),10);if(ce(r.algorithm.hash)!==o)throw H(`SHA-${o}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!oe(r.algorithm,"RSA-PSS"))throw H("RSA-PSS");const o=parseInt(e.slice(2),10);if(ce(r.algorithm.hash)!==o)throw H(`SHA-${o}`,"algorithm.hash");break}case"EdDSA":{if(r.algorithm.name!=="Ed25519"&&r.algorithm.name!=="Ed448")throw H("Ed25519 or Ed448");break}case"ES256":case"ES384":case"ES512":{if(!oe(r.algorithm,"ECDSA"))throw H("ECDSA");const o=je(e);if(r.algorithm.namedCurve!==o)throw H(o,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}Ke(r,t)}function pe(r,e,...t){var o;if(t.length>2){const i=t.pop();r+=`one of type ${t.join(", ")}, or ${i}.`}else t.length===2?r+=`one of type ${t[0]} or ${t[1]}.`:r+=`of type ${t[0]}.`;return e==null?r+=` Received ${e}`:typeof e=="function"&&e.name?r+=` Received function ${e.name}`:typeof e=="object"&&e!=null&&(o=e.constructor)!=null&&o.name&&(r+=` Received an instance of ${e.constructor.name}`),r}const ye=(r,...e)=>pe("Key must be ",r,...e);function we(r,e,...t){return pe(`Key for the ${r} algorithm must be `,e,...t)}const me=r=>ge(r)?!0:(r==null?void 0:r[Symbol.toStringTag])==="KeyObject",ie=["CryptoKey"],De=(...r)=>{const e=r.filter(Boolean);if(e.length===0||e.length===1)return!0;let t;for(const o of e){const i=Object.keys(o);if(!t||t.size===0){t=new Set(i);continue}for(const n of i){if(t.has(n))return!1;t.add(n)}}return!0};function ze(r){return typeof r=="object"&&r!==null}function X(r){if(!ze(r)||Object.prototype.toString.call(r)!=="[object Object]")return!1;if(Object.getPrototypeOf(r)===null)return!0;let e=r;for(;Object.getPrototypeOf(e)!==null;)e=Object.getPrototypeOf(e);return Object.getPrototypeOf(r)===e}const We=(r,e)=>{if(r.startsWith("RS")||r.startsWith("PS")){const{modulusLength:t}=e.algorithm;if(typeof t!="number"||t<2048)throw new TypeError(`${r} requires key modulusLength to be 2048 bits or larger`)}};function Fe(r){let e,t;switch(r.kty){case"RSA":{switch(r.alg){case"PS256":case"PS384":case"PS512":e={name:"RSA-PSS",hash:`SHA-${r.alg.slice(-3)}`},t=r.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":e={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${r.alg.slice(-3)}`},t=r.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":e={name:"RSA-OAEP",hash:`SHA-${parseInt(r.alg.slice(-3),10)||1}`},t=r.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new O('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"EC":{switch(r.alg){case"ES256":e={name:"ECDSA",namedCurve:"P-256"},t=r.d?["sign"]:["verify"];break;case"ES384":e={name:"ECDSA",namedCurve:"P-384"},t=r.d?["sign"]:["verify"];break;case"ES512":e={name:"ECDSA",namedCurve:"P-521"},t=r.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":e={name:"ECDH",namedCurve:r.crv},t=r.d?["deriveBits"]:[];break;default:throw new O('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"OKP":{switch(r.alg){case"EdDSA":e={name:r.crv},t=r.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":e={name:r.crv},t=r.d?["deriveBits"]:[];break;default:throw new O('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}default:throw new O('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:e,keyUsages:t}}const ve=async r=>{if(!r.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:e,keyUsages:t}=Fe(r),o=[e,r.ext??!1,r.key_ops??t],i={...r};return delete i.alg,delete i.use,ee.subtle.importKey("jwk",i,...o)},ke=r=>$(r);let de,he;const Ce=r=>(r==null?void 0:r[Symbol.toStringTag])==="KeyObject",_e=async(r,e,t,o)=>{let i=r.get(e);if(i!=null&&i[o])return i[o];const n=await ve({...t,alg:o});return i?i[o]=n:r.set(e,{[o]:n}),n},Je=(r,e)=>{if(Ce(r)){let t=r.export({format:"jwk"});return delete t.d,delete t.dp,delete t.dq,delete t.p,delete t.q,delete t.qi,t.k?ke(t.k):(he||(he=new WeakMap),_e(he,r,t,e))}return r},Me=(r,e)=>{if(Ce(r)){let t=r.export({format:"jwk"});return t.k?ke(t.k):(de||(de=new WeakMap),_e(de,r,t,e))}return r},Be={normalizePublicKey:Je,normalizePrivateKey:Me},x=(r,e,t=0)=>{t===0&&(e.unshift(e.length),e.unshift(6));const o=r.indexOf(e[0],t);if(o===-1)return!1;const i=r.subarray(o,o+e.length);return i.length!==e.length?!1:i.every((n,s)=>n===e[s])||x(r,e,o+1)},Se=r=>{switch(!0){case x(r,[42,134,72,206,61,3,1,7]):return"P-256";case x(r,[43,129,4,0,34]):return"P-384";case x(r,[43,129,4,0,35]):return"P-521";case x(r,[43,101,110]):return"X25519";case x(r,[43,101,111]):return"X448";case x(r,[43,101,112]):return"Ed25519";case x(r,[43,101,113]):return"Ed448";default:throw new O("Invalid or unsupported EC Key Curve or OKP Key Sub Type")}},Te=async(r,e,t,o,i)=>{let n,s;const a=new Uint8Array(atob(t.replace(r,"")).split("").map(u=>u.charCodeAt(0))),d=e==="spki";switch(o){case"PS256":case"PS384":case"PS512":n={name:"RSA-PSS",hash:`SHA-${o.slice(-3)}`},s=d?["verify"]:["sign"];break;case"RS256":case"RS384":case"RS512":n={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${o.slice(-3)}`},s=d?["verify"]:["sign"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":n={name:"RSA-OAEP",hash:`SHA-${parseInt(o.slice(-3),10)||1}`},s=d?["encrypt","wrapKey"]:["decrypt","unwrapKey"];break;case"ES256":n={name:"ECDSA",namedCurve:"P-256"},s=d?["verify"]:["sign"];break;case"ES384":n={name:"ECDSA",namedCurve:"P-384"},s=d?["verify"]:["sign"];break;case"ES512":n={name:"ECDSA",namedCurve:"P-521"},s=d?["verify"]:["sign"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{const u=Se(a);n=u.startsWith("P-")?{name:"ECDH",namedCurve:u}:{name:u},s=d?[]:["deriveBits"];break}case"EdDSA":n={name:Se(a)},s=d?["verify"]:["sign"];break;default:throw new O('Invalid or unsupported "alg" (Algorithm) value')}return ee.subtle.importKey(e,a,n,!1,s)},Le=(r,e,t)=>Te(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g,"pkcs8",r,e),$e=(r,e,t)=>Te(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g,"spki",r,e);async function qe(r,e,t){if(typeof r!="string"||r.indexOf("-----BEGIN PUBLIC KEY-----")!==0)throw new TypeError('"spki" must be SPKI formatted string');return $e(r,e)}async function Ve(r,e,t){if(typeof r!="string"||r.indexOf("-----BEGIN PRIVATE KEY-----")!==0)throw new TypeError('"pkcs8" must be PKCS#8 formatted string');return Le(r,e)}async function be(r,e){if(!X(r))throw new TypeError("JWK must be an object");switch(e||(e=r.alg),r.kty){case"oct":if(typeof r.k!="string"||!r.k)throw new TypeError('missing "k" (Key Value) Parameter value');return $(r.k);case"RSA":if(r.oth!==void 0)throw new O('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return ve({...r,alg:e});default:throw new O('Unsupported "kty" (Key Type) Parameter value')}}const se=r=>r==null?void 0:r[Symbol.toStringTag],Ge=(r,e)=>{if(!(e instanceof Uint8Array)){if(!me(e))throw new TypeError(we(r,e,...ie,"Uint8Array"));if(e.type!=="secret")throw new TypeError(`${se(e)} instances for symmetric algorithms must be of type "secret"`)}},Ye=(r,e,t)=>{if(!me(e))throw new TypeError(we(r,e,...ie));if(e.type==="secret")throw new TypeError(`${se(e)} instances for asymmetric algorithms must not be of type "secret"`);if(e.algorithm&&t==="verify"&&e.type==="private")throw new TypeError(`${se(e)} instances for asymmetric algorithm verifying must be of type "public"`);if(e.algorithm&&t==="encrypt"&&e.type==="private")throw new TypeError(`${se(e)} instances for asymmetric algorithm encryption must be of type "public"`)},Xe=(r,e,t)=>{r.startsWith("HS")||r==="dir"||r.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(r)?Ge(r,e):Ye(r,e,t)};function Qe(r,e,t,o,i){if(i.crit!==void 0&&(o==null?void 0:o.crit)===void 0)throw new r('"crit" (Critical) Header Parameter MUST be integrity protected');if(!o||o.crit===void 0)return new Set;if(!Array.isArray(o.crit)||o.crit.length===0||o.crit.some(s=>typeof s!="string"||s.length===0))throw new r('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let n;n=e;for(const s of o.crit){if(!n.has(s))throw new O(`Extension Header Parameter "${s}" is not recognized`);if(i[s]===void 0)throw new r(`Extension Header Parameter "${s}" is missing`);if(n.get(s)&&o[s]===void 0)throw new r(`Extension Header Parameter "${s}" MUST be integrity protected`)}return new Set(o.crit)}function Ze(r,e){const t=`SHA-${r.slice(-3)}`;switch(r){case"HS256":case"HS384":case"HS512":return{hash:t,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:t,name:"RSA-PSS",saltLength:r.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:t,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:t,name:"ECDSA",namedCurve:e.namedCurve};case"EdDSA":return{name:e.name};default:throw new O(`alg ${r} is not supported either by JOSE or your javascript runtime`)}}async function er(r,e,t){if(e=await Be.normalizePublicKey(e,r),ge(e))return xe(e,r,t),e;if(e instanceof Uint8Array){if(!r.startsWith("HS"))throw new TypeError(ye(e,...ie));return ee.subtle.importKey("raw",e,{hash:`SHA-${r.slice(-3)}`,name:"HMAC"},!1,[t])}throw new TypeError(ye(e,...ie,"Uint8Array"))}const rr=async(r,e,t,o)=>{const i=await er(r,e,"verify");We(r,i);const n=Ze(r,i.algorithm);try{return await ee.subtle.verify(n,i,t,o)}catch{return!1}};async function tr(r,e,t){if(!X(r))throw new b("Flattened JWS must be an object");if(r.protected===void 0&&r.header===void 0)throw new b('Flattened JWS must have either of the "protected" or "header" members');if(r.protected!==void 0&&typeof r.protected!="string")throw new b("JWS Protected Header incorrect type");if(r.payload===void 0)throw new b("JWS Payload missing");if(typeof r.signature!="string")throw new b("JWS Signature missing or incorrect type");if(r.header!==void 0&&!X(r.header))throw new b("JWS Unprotected Header incorrect type");let o={};if(r.protected)try{const lr=$(r.protected);o=JSON.parse(Y.decode(lr))}catch{throw new b("JWS Protected Header is invalid")}if(!De(o,r.header))throw new b("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const i={...o,...r.header},n=Qe(b,new Map([["b64",!0]]),void 0,o,i);let s=!0;if(n.has("b64")&&(s=o.b64,typeof s!="boolean"))throw new b('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:a}=i;if(typeof a!="string"||!a)throw new b('JWS "alg" (Algorithm) Header Parameter missing or invalid');if(s){if(typeof r.payload!="string")throw new b("JWS Payload must be a string")}else if(typeof r.payload!="string"&&!(r.payload instanceof Uint8Array))throw new b("JWS Payload must be a string or an Uint8Array instance");let d=!1;typeof e=="function"&&(e=await e(o,r),d=!0),Xe(a,e,"verify");const u=Oe(re.encode(r.protected??""),re.encode("."),typeof r.payload=="string"?re.encode(r.payload):r.payload);let w;try{w=$(r.signature)}catch{throw new b("Failed to base64url decode the signature")}if(!await rr(a,e,w,u))throw new He;let _;if(s)try{_=$(r.payload)}catch{throw new b("Failed to base64url decode the payload")}else typeof r.payload=="string"?_=re.encode(r.payload):_=r.payload;const ae={payload:_};return r.protected!==void 0&&(ae.protectedHeader=o),r.header!==void 0&&(ae.unprotectedHeader=r.header),d?{...ae,key:e}:ae}async function or(r,e,t){if(r instanceof Uint8Array&&(r=Y.decode(r)),typeof r!="string")throw new b("Compact JWS must be a string or Uint8Array");const{0:o,1:i,2:n,length:s}=r.split(".");if(s!==3)throw new b("Invalid Compact JWS");const a=await tr({payload:i,protected:o,signature:n},e),d={payload:a.payload,protectedHeader:a.protectedHeader};return typeof e=="function"?{...d,key:a.key}:d}const Ae=$;function ir(r){let e;if(typeof r=="string"){const t=r.split(".");(t.length===3||t.length===5)&&([e]=t)}else if(typeof r=="object"&&r)if("protected"in r)e=r.protected;else throw new TypeError("Token does not contain a Protected Header");try{if(typeof e!="string"||!e)throw new Error;const t=JSON.parse(Y.decode(Ae(e)));if(!X(t))throw new Error;return t}catch{throw new TypeError("Invalid Token or Protected Header formatting")}}function sr(r){if(typeof r!="string")throw new M("JWTs must use Compact JWS serialization, JWT must be a string");const{1:e,length:t}=r.split(".");if(t===5)throw new M("Only JWTs using Compact JWS serialization can be decoded");if(t!==3)throw new M("Invalid JWT");if(!e)throw new M("JWTs must contain a payload");let o;try{o=Ae(e)}catch{throw new M("Failed to base64url decode the payload")}let i;try{i=JSON.parse(Y.decode(o))}catch{throw new M("Failed to parse the decoded payload as JSON")}if(!X(i))throw new M("Invalid JWT Claims Set");return i}const T=class C{static flowNames(e){let t={};return e.forEach(o=>{o in C.flowName&&(t[o]=C.flowName[o])}),t}static isValidFlow(e){return C.allFlows().includes(e)}static areAllValidFlows(e){let t=!0;return e.forEach(o=>{C.isValidFlow(o)||(t=!1)}),t}static allFlows(){return[C.AuthorizationCode,C.AuthorizationCodeWithPKCE,C.ClientCredentials,C.RefreshToken,C.DeviceCode,C.Password,C.PasswordMfa,C.OidcAuthorizationCode]}static grantType(e){switch(e){case C.AuthorizationCode:case C.AuthorizationCodeWithPKCE:case C.OidcAuthorizationCode:return["authorization_code"];case C.ClientCredentials:return["client_credentials"];case C.RefreshToken:return["refresh_token"];case C.Password:return["password"];case C.PasswordMfa:return["http://auth0.com/oauth/grant-type/mfa-otp","http://auth0.com/oauth/grant-type/mfa-oob"];case C.DeviceCode:return["urn:ietf:params:oauth:grant-type:device_code"]}}};l(T,"All","all"),l(T,"AuthorizationCode","authorizationCode"),l(T,"AuthorizationCodeWithPKCE","authorizationCodeWithPKCE"),l(T,"ClientCredentials","clientCredentials"),l(T,"RefreshToken","refreshToken"),l(T,"DeviceCode","deviceCode"),l(T,"Password","password"),l(T,"PasswordMfa","passwordMfa"),l(T,"OidcAuthorizationCode","oidcAuthorizationCode"),l(T,"flowName",{[T.AuthorizationCode]:"Authorization Code",[T.AuthorizationCodeWithPKCE]:"Authorization Code with PKCE",[T.ClientCredentials]:"Client Credentials",[T.RefreshToken]:"Refresh Token",[T.DeviceCode]:"Device Code",[T.Password]:"Password",[T.PasswordMfa]:"Password MFA",[T.OidcAuthorizationCode]:"OIDC Authorization Code"});var A,E,Q,B,L;class nr{constructor({authServerBaseUrl:e,client_id:t,client_secret:o,redirect_uri:i,codeChallengeMethod:n,stateLength:s,verifierLength:a,tokenConsumer:d,authServerCredentials:u,authServerMode:w,authServerHeaders:_}){l(this,"authServerBaseUrl",""),G(this,A),G(this,E),G(this,Q),l(this,"codeChallengeMethod","S256"),G(this,B),l(this,"verifierLength",32),l(this,"redirect_uri"),G(this,L,""),l(this,"stateLength",32),l(this,"authzCode",""),l(this,"oidcConfig"),l(this,"tokenConsumer"),l(this,"authServerHeaders",{}),l(this,"authServerMode"),l(this,"authServerCredentials"),this.tokenConsumer=d,this.authServerBaseUrl=e,a&&(this.verifierLength=a),s&&(this.stateLength=s),t&&I(this,A,t),o&&I(this,E,o),i&&(this.redirect_uri=i),n&&(this.codeChallengeMethod=n),this.authServerBaseUrl=e,u&&(this.authServerCredentials=u),w&&(this.authServerMode=w),_&&(this.authServerHeaders=_)}set client_id(e){I(this,A,e)}set client_secret(e){I(this,E,e)}set codeVerifier(e){I(this,B,e)}set codeChallenge(e){I(this,Q,e)}set state(e){I(this,L,e)}async loadConfig(e){if(e){c.logger.debug(h({msg:"Reading OIDC config locally"})),this.oidcConfig=e;return}let t;try{const o=new URL(this.authServerBaseUrl+"/.well-known/openid-configuration");c.logger.debug(h({msg:`Fetching OIDC config from ${o}`}));let i={headers:this.authServerHeaders};this.authServerMode&&(i.mode=this.authServerMode),this.authServerCredentials&&(i.credentials=this.authServerCredentials),t=await fetch(o,i)}catch(o){c.logger.error(h({err:o}))}if(!t||!t.ok)throw new g(k.Connection,"Couldn't get OIDC configuration from URL"+this.authServerBaseUrl+"/.well-known/openid-configuration");this.oidcConfig={...fe};try{const o=await t.json();for(const[i,n]of Object.entries(o))this.oidcConfig[i]=n}catch{throw new g(k.Connection,"Unrecognized response from OIDC configuration endpoint")}}getOidcConfig(){return this.oidcConfig}async startAuthorizationCodeFlow(e,t=!1){var o,i,n;if(c.logger.debug(h({msg:"Starting authorization code flow"})),this.oidcConfig||await this.loadConfig(),!((o=this.oidcConfig)!=null&&o.response_types_supported.includes("code"))||!((i=this.oidcConfig)!=null&&i.response_modes_supported.includes("query")))return{error:"invalid_request",error_description:"Server does not support authorization code flow"};if(!((n=this.oidcConfig)!=null&&n.authorization_endpoint))return{error:"server_error",error_description:"Cannot get authorize endpoint"};if(I(this,L,this.randomValue(this.stateLength)),!p(this,A))return{error:"invalid_request",error_description:"Cannot make authorization code flow without client id"};if(!this.redirect_uri)return{error:"invalid_request",error_description:"Cannot make authorization code flow without Redirect Uri"};let s=this.oidcConfig.authorization_endpoint+"?response_type=code&client_id="+encodeURIComponent(p(this,A))+"&state="+encodeURIComponent(p(this,L))+"&redirect_uri="+encodeURIComponent(this.redirect_uri);return e&&(s+="&scope="+encodeURIComponent(e)),t&&(I(this,B,this.randomValue(this.verifierLength)),I(this,Q,this.codeChallengeMethod=="plain"?p(this,B):await this.sha256(p(this,B))),s+="&code_challenge="+p(this,Q)),{url:s}}async redirectEndpoint(e,t,o,i){var n,s;if(this.oidcConfig||await this.loadConfig(),o||!e)return o||(o="server_error"),i||(i="Unknown error"),{error:o,error_description:i};if(p(this,L)&&t!=p(this,L))return{error:"access_denied",error_description:"State is not valid"};if(this.authzCode=e,!((n=this.oidcConfig)!=null&&n.grant_types_supported.includes("authorization_code")))return{error:"invalid_request",error_description:"Server does not support authorization code grant"};if(!((s=this.oidcConfig)!=null&&s.token_endpoint))return{error:"server_error",error_description:"Cannot get token endpoint"};const a=this.oidcConfig.token_endpoint;let d,u;d="authorization_code",u=p(this,E);let w={grant_type:d,client_id:p(this,A),code:this.authzCode};u&&(w.client_secret=u),w.code_verifier=p(this,B);try{const _=await this.post(a,w,this.authServerHeaders);return _.id_token&&!await this.validateIdToken(_.id_token)?{error:"access_denied",error_description:"Invalid ID token"}:_}catch(_){return c.logger.error(h({err:_})),{error:"server_error",error_description:"Unable to get access token from server"}}}async clientCredentialsFlow(e){var t,o;if(c.logger.debug(h({msg:"Starting client credentials flow"})),this.oidcConfig||await this.loadConfig(),!((t=this.oidcConfig)!=null&&t.grant_types_supported.includes("client_credentials")))return{error:"invalid_request",error_description:"Server does not support client credentials grant"};if(!((o=this.oidcConfig)!=null&&o.token_endpoint))return{error:"server_error",error_description:"Cannot get token endpoint"};if(!p(this,A))return{error:"invalid_request",error_description:"Cannot make client credentials flow without client id"};const i=this.oidcConfig.token_endpoint;let n={grant_type:"client_credentials",client_id:p(this,A),client_secret:p(this,E)};e&&(n.scope=e);try{return await this.post(i,n,this.authServerHeaders)}catch(s){return c.logger.error(h({err:s})),{error:"server_error",error_description:"Error connecting to authorization server"}}}async passwordFlow(e,t,o){var i,n;if(c.logger.debug(h({msg:"Starting password flow"})),this.oidcConfig||await this.loadConfig(),!((i=this.oidcConfig)!=null&&i.grant_types_supported.includes("password")))return{error:"invalid_request",error_description:"Server does not support password grant"};if(!((n=this.oidcConfig)!=null&&n.token_endpoint))return{error:"server_error",error_description:"Cannot get token endpoint"};const s=this.oidcConfig.token_endpoint;let a={grant_type:"password",client_id:p(this,A),client_secret:p(this,E),username:e,password:t};o&&(a.scope=o);try{let d=await this.post(s,a,this.authServerHeaders);return d.id_token&&!await this.validateIdToken(d.id_token)?{error:"access_denied",error_description:"Invalid ID token"}:d}catch(d){return c.logger.error(h({err:d})),{error:"server_error",error_description:"Error connecting to authorization server"}}}async mfaAuthenticators(e){var t,o,i;if(c.logger.debug(h({msg:"Getting valid MFA authenticators"})),this.oidcConfig||await this.loadConfig(),!((t=this.oidcConfig)!=null&&t.grant_types_supported.includes("http://auth0.com/oauth/grant-type/mfa-otp"))&&(o=this.oidcConfig)!=null&&o.grant_types_supported.includes("http://auth0.com/oauth/grant-type/mfa-oob"))return{error:"invalid_request",error_description:"Server does not support password_mfa grant"};if(!((i=this.oidcConfig)!=null&&i.issuer))return{error:"server_error",error_description:"Cannot get issuer"};const n=this.oidcConfig.issuer+(this.oidcConfig.issuer.endsWith("/")?"":"/")+"mfa/authenticators",s=await this.get(n,{authorization:"Bearer "+e,...this.authServerHeaders});if(!Array.isArray(s))return{error:"server_error",error_description:"Expected array of authenticators in mfa/authenticators response"};let a=[];for(let d=0;d<s.length;++d){const u=s[d];if(!u.id||!u.authenticator_type||!u.active)return{error:"server_error",error_description:"Invalid mfa/authenticators response"};a.push({id:u.id,authenticator_type:u.authenticator_type,active:u.active,name:u.name,oob_channel:u.oob_channel})}return{authenticators:a}}async mfaOtpRequest(e,t){var o,i;if(c.logger.debug(h({msg:"Making MFA OTB request"})),this.oidcConfig||await this.loadConfig(),!((o=this.oidcConfig)!=null&&o.grant_types_supported.includes("http://auth0.com/oauth/grant-type/mfa-otp")))return{error:"invalid_request",error_description:"Server does not support password_mfa grant"};if(!((i=this.oidcConfig)!=null&&i.issuer))return{error:"server_error",error_description:"Cannot get issuer"};const n=this.oidcConfig.issuer+(this.oidcConfig.issuer.endsWith("/")?"":"/")+"mfa/challenge",s=await this.post(n,{client_id:p(this,A),client_secret:p(this,E),challenge_type:"otp",mfa_token:e,authenticator_id:t},this.authServerHeaders);return s.challenge_type!="otp"?{error:s.error??"server_error",error_description:s.error_description??"Invalid OTP challenge response"}:s}async mfaOtpComplete(e,t,o){var i,n;if(c.logger.debug(h({msg:"Completing MFA OTP request"})),this.oidcConfig||await this.loadConfig(),!((i=this.oidcConfig)!=null&&i.grant_types_supported.includes("http://auth0.com/oauth/grant-type/mfa-otp")))return{error:"invalid_request",error_description:"Server does not support password_mfa grant"};if(!((n=this.oidcConfig)!=null&&n.issuer))return{error:"server_error",error_description:"Cannot get issuer"};const s=this.oidcConfig.token_endpoint,a=await this.post(s,{grant_type:"http://auth0.com/oauth/grant-type/mfa-otp",client_id:p(this,A),client_secret:p(this,E),challenge_type:"otp",mfa_token:e,otp:t,scope:o},this.authServerHeaders);return{id_token:a.id_token,access_token:a.access_token,refresh_token:a.refresh_token,expires_in:Number(a.expires_in),scope:a.scope,token_type:a.token_type,error:a.error,error_description:a.error_description}}async mfaOobRequest(e,t){var o,i;if(c.logger.debug(h({msg:"Making MFA OOB request"})),this.oidcConfig||await this.loadConfig(),!((o=this.oidcConfig)!=null&&o.grant_types_supported.includes("http://auth0.com/oauth/grant-type/mfa-otp")))return{error:"invalid_request",error_description:"Server does not support password_mfa grant"};if(!((i=this.oidcConfig)!=null&&i.issuer))return{error:"server_error",error_description:"Cannot get issuer"};const n=this.oidcConfig.issuer+(this.oidcConfig.issuer.endsWith("/")?"":"/")+"mfa/challenge",s=await this.post(n,{client_id:p(this,A),client_secret:p(this,E),challenge_type:"oob",mfa_token:e,authenticator_id:t},this.authServerHeaders);return s.challenge_type!="oob"||!s.oob_code||!s.binding_method?{error:s.error??"server_error",error_description:s.error_description??"Invalid OOB challenge response"}:{challenge_type:s.challenge_type,oob_code:s.oob_code,binding_method:s.binding_method,error:s.error,error_description:s.error_description}}async mfaOobComplete(e,t,o,i){var n,s;if(c.logger.debug(h({msg:"Completing MFA OOB request"})),this.oidcConfig||await this.loadConfig(),!((n=this.oidcConfig)!=null&&n.grant_types_supported.includes("http://auth0.com/oauth/grant-type/mfa-oob")))return{error:"invalid_request",error_description:"Server does not support password_mfa grant"};if(!((s=this.oidcConfig)!=null&&s.issuer))return{error:"server_error",error_description:"Cannot get issuer"};const a=this.oidcConfig.token_endpoint,d=await this.post(a,{grant_type:"http://auth0.com/oauth/grant-type/mfa-oob",client_id:p(this,A),client_secret:p(this,E),challenge_type:"otp",mfa_token:e,oob_code:t,binding_code:o,scope:i},this.authServerHeaders);return d.error?{error:d.error,error_description:d.error_description}:d.id_token&&!await this.validateIdToken(d.id_token)?{error:"access_denied",error_description:"Invalid ID token"}:{id_token:d.id_token,access_token:d.access_token,refresh_token:d.refresh_token,expires_in:"expires_in"in d?Number(d.expires_in):void 0,scope:d.scope,token_type:d.token_type}}async refreshTokenFlow(e){var t,o;if(c.logger.debug(h({msg:"Starting refresh token flow"})),this.oidcConfig||await this.loadConfig(),!((t=this.oidcConfig)!=null&&t.grant_types_supported.includes("refresh_token")))return{error:"invalid_request",error_description:"Server does not support refresh_token grant"};if(!((o=this.oidcConfig)!=null&&o.token_endpoint))return{error:"server_error",error_description:"Cannot get token endpoint"};const i=this.oidcConfig.token_endpoint;let n;n=p(this,E);let s={grant_type:"refresh_token",refresh_token:e,client_id:p(this,A)};n&&(s.client_secret=n);try{let a=await this.post(i,s,this.authServerHeaders);return a.id_token&&!await this.validateIdToken(a.id_token)?{error:"access_denied",error_description:"Invalid ID token"}:a}catch(a){return c.logger.error(h({err:a})),{error:"server_error",error_description:"Error connecting to authorization server"}}}async startDeviceCodeFlow(e,t){var o;if(c.logger.debug(h({msg:"Starting device code flow"})),this.oidcConfig||await this.loadConfig(),!((o=this.oidcConfig)!=null&&o.grant_types_supported.includes("urn:ietf:params:oauth:grant-type:device_code")))return{error:"invalid_request",error_description:"Server does not support device code grant"};let i={grant_type:"urn:ietf:params:oauth:grant-type:device_code",client_id:p(this,A),client_secret:p(this,E)};t&&(i.scope=t);try{let n=await this.post(e,i,this.authServerHeaders);return n.id_token&&!await this.validateIdToken(n.id_token)?{error:"access_denied",error_description:"Invalid ID token"}:n}catch(n){return c.logger.error(h({err:n})),{error:"server_error",error_description:"Error connecting to authorization server"}}}async pollDeviceCodeFlow(e){var t,o,i;if(c.logger.debug(h({msg:"Starting device code flow"})),this.oidcConfig||await this.loadConfig(),!((t=this.oidcConfig)!=null&&t.grant_types_supported.includes("urn:ietf:params:oauth:grant-type:device_code")))return{error:"invalid_request",error_description:"Server does not support device code grant"};if(!((o=this.oidcConfig)!=null&&o.token_endpoint))return{error:"server_error",error_description:"Cannot get token endpoint"};let n={grant_type:"urn:ietf:params:oauth:grant-type:device_code",client_id:p(this,A),client_secret:p(this,E),device_code:e};try{const s=await this.post((i=this.oidcConfig)==null?void 0:i.token_endpoint,n,this.authServerHeaders);return s.error?s:s.id_token&&!await this.validateIdToken(s.id_token)?{error:"access_denied",error_description:"Invalid ID token"}:s}catch(s){return c.logger.error(h({err:s})),{error:"server_error",error_description:"Error connecting to authorization server"}}}async post(e,t,o={}){c.logger.debug(h({msg:"Fetch POST",url:e,params:Object.keys(t)}));let i={};return this.authServerCredentials&&(i.credentials=this.authServerCredentials),this.authServerMode&&(i.mode=this.authServerMode),await(await fetch(e,{method:"POST",...i,headers:{Accept:"application/json","Content-Type":"application/json",...o},body:JSON.stringify(t)})).json()}async get(e,t={}){c.logger.debug(h({msg:"Fetch GET",url:e}));let o={};return this.authServerCredentials&&(o.credentials=this.authServerCredentials),this.authServerMode&&(o.mode=this.authServerMode),await(await fetch(e,{method:"GET",...o,headers:{Accept:"application/json","Content-Type":"application/json",...t}})).json()}async validateIdToken(e){try{return await this.tokenConsumer.tokenAuthorized(e,"id")}catch{return}}async idTokenAuthorized(e){try{return await this.tokenConsumer.tokenAuthorized(e,"id")}catch(t){c.logger.warn(h({err:t}));return}}getTokenPayload(e){return sr(e)}}A=new WeakMap,E=new WeakMap,Q=new WeakMap,B=new WeakMap,L=new WeakMap;class ar{constructor(e,t={}){if(l(this,"audience"),l(this,"jwtKeyType"),l(this,"jwtSecretKey"),l(this,"jwtPublicKey"),l(this,"clockTolerance",10),l(this,"authServerBaseUrl",""),l(this,"oidcConfig"),l(this,"keys",{}),this.audience=e,t.authServerBaseUrl&&(this.authServerBaseUrl=t.authServerBaseUrl),t.jwtKeyType&&(this.jwtKeyType=t.jwtKeyType),t.jwtSecretKey&&(this.jwtSecretKey=t.jwtSecretKey),t.jwtPublicKey&&(this.jwtPublicKey=t.jwtPublicKey),t.clockTolerance&&(this.clockTolerance=t.clockTolerance),t.oidcConfig&&(this.oidcConfig=t.oidcConfig),this.jwtPublicKey&&!this.jwtKeyType)throw new g(k.Configuration,"If specifying jwtPublic key, must also specify jwtKeyType")}async loadKeys(){try{if(this.jwtSecretKey){if(!this.jwtKeyType)throw new g(k.Configuration,"Must specify jwtKeyType if setting jwtSecretKey");this.keys._default=await Ve(this.jwtSecretKey,this.jwtKeyType)}else if(this.jwtPublicKey){if(!this.jwtKeyType)throw new g(k.Configuration,"Must specify jwtKeyType if setting jwtPublicKey");const e=await qe(this.jwtPublicKey,this.jwtKeyType);this.keys._default=e}else{if(this.oidcConfig||await this.loadConfig(),!this.oidcConfig)throw new g(k.Connection,"Load OIDC config before Jwks");await this.loadJwks()}}catch(e){throw c.logger.debug(h({err:e})),new g(k.Connection,"Couldn't load keys")}}async loadConfig(e){if(e){this.oidcConfig=e;return}if(!this.authServerBaseUrl)throw new g(k.Connection,"Couldn't get OIDC configuration.  Either set authServerBaseUrl or set config manually");let t;try{t=await fetch(new URL("/.well-known/openid-configuration",this.authServerBaseUrl))}catch(o){c.logger.error(h({err:o}))}if(!t||!t.ok)throw new g(k.Connection,"Couldn't get OIDC configuration");this.oidcConfig={...fe};try{const o=await t.json();for(const[i,n]of Object.entries(o))this.oidcConfig[i]=n}catch{throw new g(k.Connection,"Unrecognized response from OIDC configuration endpoint")}}async loadJwks(e){if(e){this.keys={};for(let t=0;t<e.keys.length;++t){const o=e.keys[t];this.keys[o.kid??"_default"]=await be(e.keys[t])}}else{if(!this.oidcConfig)throw new g(k.Connection,"Load OIDC config before Jwks");let t;try{t=await fetch(new URL(this.oidcConfig.jwks_uri))}catch(o){c.logger.error(h({err:o}))}if(!t||!t.ok)throw new g(k.Connection,"Couldn't get OIDC configuration");this.keys={};try{const o=await t.json();if(!("keys"in o)||!Array.isArray(o.keys))throw new g(k.Connection,"Couldn't fetch keys");for(let i=0;i<o.keys.length;++i)try{let n="_default";"kid"in o.keys[i]&&typeof o.keys[i]=="string"&&(n=String(o.keys[i]));const s=await be(o.keys[i]);this.keys[n]=s}catch(n){throw c.logger.error(h({err:n})),new g(k.Connection,"Couldn't load keys")}}catch(o){throw c.logger.error(h({err:o})),new g(k.Connection,"Unrecognized response from OIDC jwks endpoint")}}}async tokenAuthorized(e,t){(!this.keys||Object.keys(this.keys).length==0)&&await this.loadKeys();const o=await this.validateToken(e);if(o){if(o.type!=t){c.logger.error(h({msg:t+" expected but got "+o.type}));return}if(o.iss!=this.authServerBaseUrl){c.logger.error(h({msg:`Invalid issuer ${o.iss} in access token`,hashedAccessToken:await this.hash(o.jti)}));return}if(o.aud&&(Array.isArray(o.aud)&&!o.aud.includes(this.audience)||!Array.isArray(o.aud)&&o.aud!=this.audience)){c.logger.error(h({msg:`Invalid audience ${o.aud} in access token`,hashedAccessToken:await this.hash(o.jti)}));return}return o}}async validateToken(e){(!this.keys||Object.keys(this.keys).length==0)&&c.logger.warn("No keys loaded so cannot validate tokens");let t;try{t=ir(e).kid}catch{c.logger.warn(h({msg:"Invalid access token format"}));return}let o;"_default"in this.keys&&(o=this.keys._default);for(let i in this.keys)if(t==i){o=this.keys[i];break}if(!o){c.logger.warn(h({msg:"No matching keys found for access token"}));return}try{const{payload:i}=await or(e,o),n=JSON.parse(new TextDecoder().decode(i));if(n.exp*1e3<Date.now()+this.clockTolerance){c.logger.warn(h({msg:"Access token has expired"}));return}return n}catch{c.logger.warn(h({msg:"Access token did not validate"}));return}}}const Ee=30,ne=2,le=30;class Pe{constructor(e){f(this,"autoRefreshUrl","/autorefresh");f(this,"csrfHeader","X-CROSSAUTH-CSRF");f(this,"headers",{});f(this,"autoRefreshActive",!1);f(this,"mode","cors");f(this,"credentials","same-origin");f(this,"tokenProvider");this.tokenProvider=e.tokenProvider,this.autoRefreshUrl=e.autoRefreshUrl,e.csrfHeader&&(this.csrfHeader=e.csrfHeader),e.headers&&(this.headers=e.headers),e.mode&&(this.mode=e.mode),e.credentials&&(this.credentials=e.credentials)}async startAutoRefresh(e=["access","id"],t){this.autoRefreshActive||(this.autoRefreshActive=!0,c.logger.debug(h({msg:"Starting auto refresh"})),await this.scheduleAutoRefresh(e,t))}stopAutoRefresh(){this.autoRefreshActive=!1,c.logger.debug(h({msg:"Stopping auto refresh"}))}async scheduleAutoRefresh(e,t){const o=this.tokenProvider.getCsrfToken(),i=o?await o:void 0,n=await this.tokenProvider.getTokenExpiries([...e,"refresh"],i);if(n.refresh==null){c.logger.debug(h({msg:"No refresh token found"}));return}const s=Date.now();let a=n.id;if((!a||n.access&&n.access<a)&&(a=n.access),!a){c.logger.debug(h({msg:"No tokens expire"}));return}const d=a*1e3-s-Ee;if(d<0){c.logger.debug(h({msg:"Expiry time has passed"}));return}if(n.refresh&&n.refresh-Ee<d){c.logger.debug(h({msg:"Refresh token has expired"}));return}let u=w=>new Promise(_=>setTimeout(_,w));c.logger.debug(h({msg:`Waiting ${d} before refreshing tokens`})),await u(d),await this.autoRefresh(e,i,t)}async autoRefresh(e,t,o){if(this.autoRefreshActive){let i,n=!1,s=0;for(;!n&&s<=ne;)try{let a={...this.headers};t&&(a[this.csrfHeader]=t),c.logger.debug(h({msg:"Initiating auto refresh"}));const d=await this.tokenProvider.jsonFetchWithToken(this.autoRefreshUrl,{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json",...a},mode:this.mode,credentials:this.credentials,body:{csrfToken:t}},"refresh");if(d.ok||c.logger.error(h({msg:"Failed auto refreshing tokens",status:d.status})),i=await d.json(),i!=null&&i.ok){await this.scheduleAutoRefresh(e,o),n=!0;try{await this.tokenProvider.receiveTokens(i)}catch(u){const w=g.asCrossauthError(u);o?o("Couldn't receive tokens",w):(c.logger.debug(h({err:u})),c.logger.error(h({msg:"Error receiving tokens",cerr:w})))}}else s<ne?(c.logger.error(h({msg:`Failed auto refreshing tokens.  Retrying in ${le} seconds`})),await(w=>new Promise(_=>setTimeout(_,w)))(le*1e3)):(c.logger.error(h({msg:"Failed auto refreshing tokens.  Number of retries exceeded"})),o&&o("Failed auto refreshing tokens")),s++}catch(a){const d=g.asCrossauthError(a);c.logger.debug(h({err:d})),s<ne?(c.logger.error(h({msg:`Failed auto refreshing tokens.  Retrying in ${ne} seconds`})),await(w=>new Promise(_=>setTimeout(_,w)))(le)):(c.logger.error(h({msg:"Failed auto refreshing tokens.  Number of retries exceeded"})),o&&o(d.message,d)),s++}}}}class Re{constructor(e){f(this,"deviceCodePollUrl","/devicecodepoll");f(this,"headers",{});f(this,"pollingActive",!1);f(this,"mode","cors");f(this,"credentials","same-origin");f(this,"respectRedirect",!0);f(this,"oauthClient");this.oauthClient=e.oauthClient,e.deviceCodePollUrl!=null&&(this.deviceCodePollUrl=e.deviceCodePollUrl),e.headers&&(this.headers=e.headers),e.mode&&(this.mode=e.mode),e.credentials&&(this.credentials=e.credentials)}async startPolling(e,t,o=5){this.pollingActive||(this.pollingActive=!0,c.logger.debug(h({msg:"Starting auto refresh"})),await this.poll(e,o,t))}stopPolling(){this.pollingActive=!1,c.logger.debug(h({msg:"Stopping auto refresh"}))}async poll(e,t,o){var i;if(!e)c.logger.debug(h({msg:"device code poll: no device code provided"})),o("error","Error waiting for authorization");else try{if(c.logger.debug(h({msg:"device code poll: poll"})),!this.deviceCodePollUrl&&this.oauthClient){if(this.oauthClient.getOidcConfig()||await this.oauthClient.loadConfig(),!((i=this.oauthClient.getOidcConfig())!=null&&i.grant_types_supported.includes("http://auth0.com/oauth/grant-type/mfa-oob")))return{error:"invalid_request",error_description:"Server does not support password_mfa grant"};let s=this.oauthClient.getOidcConfig();if(!(s!=null&&s.token_endpoint))return{error:"server_error",error_description:"Couldn't get OIDC configuration"};this.deviceCodePollUrl=s.token_endpoint}if(!this.deviceCodePollUrl)return{error:"server_error",error_description:"Must either provide deviceCodePollUrl or an oauthClient to fetch it from"};const n=await fetch(this.deviceCodePollUrl,{method:"POST",body:JSON.stringify({device_code:e}),headers:{"content-type":"application/json"}});if(n.redirected)this.pollingActive=!1,n.redirected&&o("completeAndRedirect",void 0,n.url);else if(!n.ok)this.pollingActive=!1,o("error","Received an error from the authorization server");else{const s=await n.json();if(c.logger.debug(h({msg:"device code poll: received"+JSON.stringify(s)})),s.error=="expired_token")this.pollingActive=!1,o("expired_token","Timeout waiting for authorization");else if(s.error=="authorization_pending"||s.error=="slow_down"){s.error=="slow_down"&&(t+=5);let a=s.interval??t,d=u=>new Promise(w=>setTimeout(w,u));c.logger.debug(h({msg:"device code poll: waiting "+String(a)+" seconds"})),await d(a*1e3),this.pollingActive&&this.poll(e,t,o)}else s.error?(this.pollingActive=!1,o("error",s.error_description??s.error)):(this.pollingActive=!1,o("complete"))}}catch(n){this.pollingActive=!1;const s=g.asCrossauthError(n);c.logger.debug(h({err:s})),c.logger.error(h({msg:"Polling failed",cerr:s})),o("error",s.message)}}}class cr{constructor(e={}){f(this,"bffPrefix","/bff");f(this,"csrfHeader","X-CROSSAUTH-CSRF");f(this,"enableCsrfProtection",!0);f(this,"headers",{});f(this,"mode","cors");f(this,"credentials","same-origin");f(this,"autoRefresher");f(this,"deviceCodePoller");f(this,"getCsrfTokenUrl","/api/getcsrftoken");f(this,"autoRefreshUrl","/api/refreshtokens");f(this,"tokensUrl","/tokens");e.bffPrefix&&(this.bffPrefix=e.bffPrefix),e.csrfHeader&&(this.csrfHeader=e.csrfHeader),e.enableCsrfProtection!=null&&(this.enableCsrfProtection=e.enableCsrfProtection),e.getCsrfTokenUrl&&(this.getCsrfTokenUrl=e.getCsrfTokenUrl),e.tokensUrl&&(this.tokensUrl=e.tokensUrl),e.autoRefreshUrl&&(this.autoRefreshUrl=e.autoRefreshUrl),this.bffPrefix.endsWith("/")||(this.bffPrefix+="/"),e.headers&&(this.headers=e.headers),e.mode&&(this.mode=e.mode),e.credentials&&(this.credentials=e.credentials),this.autoRefresher=new Pe({...e,autoRefreshUrl:this.autoRefreshUrl,tokenProvider:this}),this.deviceCodePoller=new Re({...e,oauthClient:void 0})}async getCsrfToken(){if(this.enableCsrfProtection)try{const t=await(await fetch(this.getCsrfTokenUrl,{headers:this.headers,credentials:this.credentials,mode:this.mode})).json();if(!t.ok)throw g.asCrossauthError(t);return t.csrfToken}catch(e){throw g.asCrossauthError(e)}}async getIdToken(e){const t=await this.getTokens(e);return(t==null?void 0:t.id_token)??null}async haveIdToken(e){const t=await this.getTokens(e);return t==null?!1:t.have_id_token!=null?t.have_id_token:"id_token"in t}async getAccessToken(e){const t=await this.getTokens(e);return(t==null?void 0:t.access_token)??null}async haveAccessToken(e){const t=await this.getTokens(e);return t==null?!1:t.have_access_token!=null?t.have_access_token:"access_token"in t}async getRefreshToken(e){const t=await this.getTokens(e);return(t==null?void 0:t.refresh_token)??null}async haveRefreshToken(e){const t=await this.getTokens(e);return t==null?!1:t.have_refresh_token!=null?t.have_refresh_token:"refresh_token"in t}async api(e,t,o,i){let n={...this.headers};!i&&!["GET","HEAD","OPTIONS"].includes(e)&&(i=await this.getCsrfToken(),i&&(n[this.csrfHeader]=i)),t.startsWith("/")&&(t=t.substring(1));let s={};o&&(s.body=JSON.stringify(o));const a=await fetch(this.bffPrefix+t,{headers:n,method:e,mode:this.mode,credentials:this.credentials,...s});let d=null;return a.body&&(d=await a.json()),{status:a.status,body:d}}async getTokens(e){e||(e=await this.getCsrfToken());let t={...this.headers};e&&(t[this.csrfHeader]=e);try{const o=await fetch(this.tokensUrl,{method:"POST",headers:t,mode:this.mode,credentials:this.credentials});return o.status==204?{}:await o.json()}catch(o){throw g.asCrossauthError(o)}}async startAutoRefresh(e=["access","id"],t){return this.autoRefresher.startAutoRefresh(e,t)}stopAutoRefresh(){return this.autoRefresher.stopAutoRefresh()}async startDeviceCodePolling(e,t,o=5){return this.deviceCodePoller.startPolling(e,t,o)}stopDeviceCodePolling(){return this.deviceCodePoller.stopPolling()}async getTokenExpiries(e,t){const o=await this.getTokens(t),i=e.includes("id")?(o==null?void 0:o.id_token)??null:null,n=e.includes("access")?(o==null?void 0:o.access_token)??null:null,s=e.includes("refresh")?(o==null?void 0:o.refresh_token)??null:null;let a,d,u;return i&&(a=i.exp?i.exp:null),n&&(d=n.exp?n.exp:null),s&&(u=s.exp?s.exp:null),{id:a,access:d,refresh:u}}async jsonFetchWithToken(e,t,o){return typeof t.body!="string"&&(t.body=JSON.stringify(t.body)),await fetch(e,t)}receiveTokens(e){return new Promise(t=>{})}}class dr extends ar{async hash(e){const o=new TextEncoder().encode(e),i=await crypto.subtle.digest("SHA-256",o),n=Array.from(new Uint8Array(i));return btoa(n.reduce((s,a)=>s+String.fromCharCode(a),"")).replace(/\//g,"_").replace(/\+/g,"-").replace(/=+$/,"")}}class hr extends nr{constructor(t){t.tokenConsumer||(t.tokenConsumer=new dr(t.client_id,{authServerBaseUrl:t.authServerBaseUrl}));super(t);f(this,"resServerBaseUrl","");f(this,"resServerHeaders",{});f(this,"resServerMode","cors");f(this,"resServerCredentials","same-origin");f(this,"accessTokenResponseType","memory");f(this,"refreshTokenResponseType","memory");f(this,"idTokenResponseType","memory");f(this,"accessTokenName","CROSSAUTH_AT");f(this,"refreshTokenName","CROSSAUTH_RT");f(this,"idTokenName","CROSSAUTH_IT");F(this,D);F(this,j);F(this,N);F(this,z);F(this,W);F(this,q);F(this,V);f(this,"autoRefresher");f(this,"deviceCodePoller");f(this,"deviceAuthorizationUrl","device_authorization");this.resServerBaseUrl!=null&&(this.resServerBaseUrl=t.resServerBaseUrl??"",this.resServerBaseUrl.length>0&&!this.resServerBaseUrl.endsWith("/")&&(this.resServerBaseUrl+="/")),t.accessTokenResponseType&&(this.accessTokenResponseType=t.accessTokenResponseType),t.idTokenResponseType&&(this.idTokenResponseType=t.idTokenResponseType),t.refreshTokenResponseType&&(this.refreshTokenResponseType=t.refreshTokenResponseType),t.accessTokenName&&(this.accessTokenName=t.accessTokenName),t.idTokenName&&(this.idTokenName=t.idTokenName),t.refreshTokenName&&(this.refreshTokenName=t.refreshTokenName),t.resServerHeaders&&(this.resServerHeaders=t.resServerHeaders),t.resServerMode&&(this.resServerMode=t.resServerMode),t.resServerCredentials&&(this.resServerCredentials=t.resServerCredentials),t.client_id&&P(this,q,t.client_id),t.client_secret&&P(this,V,t.client_secret),t.deviceAuthorizationUrl&&(this.deviceAuthorizationUrl=t.deviceAuthorizationUrl),this.autoRefresher=new Pe({...t,autoRefreshUrl:this.authServerBaseUrl+"/token",tokenProvider:this}),this.deviceCodePoller=new Re({...t,oauthClient:this,deviceCodePollUrl:null});let o,i,n;if(this.idTokenResponseType=="sessionStorage"?o=sessionStorage.getItem(this.idTokenName):this.idTokenResponseType=="localStorage"&&(o=localStorage.getItem(this.idTokenName)),this.accessTokenResponseType=="sessionStorage"?i=sessionStorage.getItem(this.accessTokenName):this.accessTokenResponseType=="localStorage"&&(i=localStorage.getItem(this.accessTokenName)),this.refreshTokenResponseType=="sessionStorage"?n=sessionStorage.getItem(this.refreshTokenName):this.refreshTokenResponseType=="localStorage"&&(n=localStorage.getItem(this.refreshTokenName)),this.receiveTokens({access_token:i,id_token:o,refresh_token:n}),i){const s=this.getTokenPayload(i);s&&(P(this,D,i),P(this,z,s))}if(n){const s=this.getTokenPayload(n);s&&(P(this,j,n),P(this,W,s))}o?this.validateIdToken(o).then(s=>{P(this,N,s),t.autoRefresh&&this.startAutoRefresh(t.autoRefresh).then().catch(a=>{c.logger.debug(h({err:a,msg:"Couldn't start auto refresh"}))})}).catch(s=>{c.logger.debug(h({err:s,msg:"Couldn't validate ID token"}))}):m(this,D)&&t.autoRefresh&&n?this.startAutoRefresh(t.autoRefresh).then().catch(s=>{c.logger.debug(h({err:s,msg:"Couldn't start auto refresh"}))}):n&&!i&&this.refreshTokenFlow(n).then(s=>{c.logger.debug(h({msg:"Refreshed tokens"})),t.autoRefresh&&this.startAutoRefresh(t.autoRefresh).then().catch(a=>{c.logger.debug(h({err:a,msg:"Couldn't start auto refresh"}))})}).catch(s=>{const a=g.asCrossauthError(s);c.logger.debug(h({err:a})),c.logger.error(h({msg:"failed refreshing tokens",cerr:a}))})}get idTokenPayload(){return m(this,N)}async handleRedirectUri(){const t=new URL(window.location.href);if(t.origin+t.pathname!=this.redirect_uri)return;const o=new URLSearchParams(window.location.search);let i,n,s,a;for(const[u,w]of o)u=="code"&&(i=w),u=="state"&&(n=w),u=="error"&&(s=w),u=="error_description"&&(a=w);if(!s&&!i)return;if(s){const u=g.fromOAuthError(s,a);throw c.logger.debug(h({err:u})),c.logger.error(h({cerr:u,msg:"Error from authorize endpoint: "+s})),u}const d=await this.redirectEndpoint(i,n,s,a);if(d.error){const u=g.fromOAuthError(d.error,a);throw c.logger.debug(h({err:u})),c.logger.error(h({cerr:u,msg:"Error from redirect endpoint: "+d.error})),u}return await this.receiveTokens(d),d}async startAutoRefresh(t=["access","id"],o){return this.autoRefresher.startAutoRefresh(t,o)}stopAutoRefresh(){return this.autoRefresher.stopAutoRefresh()}async startDeviceCodePolling(t,o,i=5){return this.deviceCodePoller.startPolling(t,o,i)}stopDeviceCodePolling(){return this.deviceCodePoller.stopPolling()}getIdToken(){return m(this,N)}randomValue(t){const o=new Uint8Array(t);return self.crypto.getRandomValues(o),btoa(o.reduce((i,n)=>i+String.fromCharCode(n),"")).replace(/\//g,"_").replace(/\+/g,"-").replace(/=+$/,"")}async sha256(t){const i=new TextEncoder().encode(t),n=await crypto.subtle.digest("SHA-256",i),s=Array.from(new Uint8Array(n));return btoa(s.reduce((a,d)=>a+String.fromCharCode(d),"")).replace(/\//g,"_").replace(/\+/g,"-").replace(/=+$/,"")}async api(t,o,i){let n={...this.resServerHeaders};o.startsWith("/")&&(o=o.substring(1));let s={};i&&(s.body=JSON.stringify(i));let a;this.accessTokenResponseType=="sessionStorage"?a=sessionStorage.getItem(this.accessTokenName):this.accessTokenResponseType=="localStorage"&&(a=localStorage.getItem(this.accessTokenName)),n.authorization="Bearer "+a;const d=await fetch(this.resServerBaseUrl+o,{headers:n,method:t,mode:this.resServerMode,credentials:this.resServerCredentials,...s});let u=null;return d.body&&(u=await d.json()),{status:d.status,body:u}}async getTokenExpiries(t,o){let i,n,s;return m(this,N)&&(i=m(this,N).exp?m(this,N).exp:null),m(this,z)&&(n=m(this,z).exp?m(this,z).exp:null),m(this,W)&&(s=m(this,W).exp?m(this,W).exp:null),{id:i,access:n,refresh:s}}async jsonFetchWithToken(t,o,i){if(i=="access"){if(!m(this,D))throw new g(k.InvalidToken,"Cannot make fetch with access token - no access token defined");o.headers||(o.headers={}),o.headers.authorization="Bearer "+m(this,D)}else{if(o.body||(o.body={}),!m(this,j))throw new g(k.InvalidToken,"Cannot make fetch with refresh token - no refresh token defined");o.body.refresh_token=m(this,j),o.body.grant_type="refresh_token"}return m(this,q)&&(o.body||(o.body={}),o.body.client_id=m(this,q),m(this,V)&&(o.body.client_secret=m(this,V))),typeof o.body!="string"&&(o.body=JSON.stringify(o.body)),await fetch(t,o)}async getCsrfToken(){}async receiveTokens(t){if(t.access_token){const o=this.getTokenPayload(t.access_token);o&&(P(this,D,t.access_token),P(this,z,o)),this.accessTokenResponseType=="localStorage"?localStorage.setItem(this.accessTokenName,t.access_token):this.accessTokenResponseType=="sessionStorage"&&sessionStorage.setItem(this.accessTokenName,t.access_token)}if(t.refresh_token){const o=this.getTokenPayload(t.refresh_token);o&&(P(this,j,t.refresh_token),P(this,W,o)),this.refreshTokenResponseType=="localStorage"?localStorage.setItem(this.refreshTokenName,t.refresh_token):this.accessTokenResponseType=="sessionStorage"&&sessionStorage.setItem(this.refreshTokenName,t.refresh_token)}if(t.id_token){const o=await this.validateIdToken(t.id_token);P(this,N,o),this.idTokenResponseType=="localStorage"?localStorage.setItem(this.idTokenName,t.id_token):this.idTokenResponseType=="sessionStorage"&&sessionStorage.setItem(this.idTokenName,t.id_token)}}async clientCredentialsFlow(t){const o=await super.clientCredentialsFlow(t);return await this.receiveTokens(o),o}async passwordFlow(t,o,i){const n=await super.passwordFlow(t,o,i);return await this.receiveTokens(n),n}async deviceCodeFlow(t){let o=this.authServerBaseUrl;return o.endsWith("/")||(o+="/"),o+=this.deviceAuthorizationUrl,await super.startDeviceCodeFlow(o,t)}async mfaOtpComplete(t,o){const i=await super.mfaOtpComplete(t,o);return await this.receiveTokens(i),i}async mfaOobComplete(t,o,i){const n=await super.mfaOobComplete(t,o,i);return await this.receiveTokens(n),n}async refreshTokenFlow(t){if(!t)if(m(this,j))t=m(this,j);else throw new g(k.InvalidToken,"Cannot refresh tokens: no refresh token present");const o=await super.refreshTokenFlow(t);return await this.receiveTokens(o),o}async authorizationCodeFlow(t,o=!1){const i=await super.startAuthorizationCodeFlow(t,o);if(i.error||!i.url){const n=g.fromOAuthError(i.error??"Couldn't create URL for authorization code flow",i.error_description);throw c.logger.debug(h({err:n})),n}location.href=i.url}}return D=new WeakMap,j=new WeakMap,N=new WeakMap,z=new WeakMap,W=new WeakMap,q=new WeakMap,V=new WeakMap,y.CrossauthError=g,y.CrossauthLogger=c,y.OAuthBffClient=cr,y.OAuthClient=hr,y.j=h,Object.defineProperty(y,Symbol.toStringTag,{value:"Module"}),y}({});
